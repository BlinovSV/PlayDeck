# Библиотеки
import math as m
import numpy as np
import streamlit as st
import plotly.graph_objects as go

# Настройка страницы для широкого режима
st.set_page_config(
    page_title='PLAY Deck',
    initial_sidebar_state='expanded',
    layout='wide',
    menu_items={
        'Help': 'https://playcad.pro/help',
        'Report a bug': 'https://forms.yandex.ru/cloud/66c8846bf47e7330d8e212a7/',
        'About': 'Это приложение чать проекта PlayCAD. v.0.5'}
)

# Кастомный CSS для полного растяжения
st.markdown(
    '''
    <style>
        .reportview-container .main .block-container{
            max-width: 100%;
            padding-top: 2rem;
            padding-right: 5rem;
            padding-left: 5rem;
            padding-bottom: 2rem;}
        .sidebar .sidebar-content {
            width: 300px;}
    </style>
    ''', unsafe_allow_html=True)

# Справочные данные
Grades = {
    220: {'R_y': 215, 'R_s': 125, 'R_lp': 145},
    250: {'R_y': 245, 'R_s': 140, 'R_lp': 160},
    280: {'R_y': 270, 'R_s': 155, 'R_lp': 175},
    320: {'R_y': 310, 'R_s': 180, 'R_lp': 190},
    350: {'R_y': 330, 'R_s': 190, 'R_lp': 200},
    390: {'R_y': 370, 'R_s': 215, 'R_lp': 210},
    420: {'R_y': 400, 'R_s': 230, 'R_lp': 225},
    450: {'R_y': 425, 'R_s': 245, 'R_lp': 240}}

Decks_GOST24045_2016 = {
    'Н57-750': {'h': 57, 'b': 187.5, 'b_wf': 93, 'b_tf': 44, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 0, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 0, 'h_1': 57, 'h_s1': 0, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 4},
    'Н60-845': {'h': 60, 'b': 211.25, 'b_wf': 122, 'b_tf': 50, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 0, 'b_wfs': 16, 'h_wfs': 5, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 0, 'h_1': 60, 'h_s1': 0, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 3.5, 'n_cor': 4},
    'Н75-750': {'h': 75, 'b': 187.5, 'b_wf': 92, 'b_tf': 50, 'n_wfs' : 1, 'n_tfs': 0, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 8, 'h_1': 48, 'h_s1': 7, 'h_2': 0, 'h_s2':0, 'r': 5, 'r_s': 4, 'n_cor': 4},
    'Н114-600': {'h': 114, 'b': 200.0, 'b_wf': 104, 'b_tf': 60, 'n_wfs': 1, 'n_tfs': 1, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 22, 'h_tfs': 7, 'h_ws': 8, 'h_1': 81, 'h_s1': 7, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 3},
    'Н114-750': {'h': 114, 'b': 250.0, 'b_wf': 126, 'b_tf': 80, 'n_wfs': 2, 'n_tfs': 1, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 42, 'b_tfs': 22, 'h_tfs': 7, 'h_ws': 8, 'h_1': 81, 'h_s1': 7, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 3},
    'Н153-850': {'h': 153, 'b': 284.0, 'b_wf': 120, 'b_tf': 43, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 29, 'h_wfs': 5, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 7, 'h_1': 30, 'h_s1': 11, 'h_2': 71, 'h_s2': 11, 'r': 3, 'r_s': 3, 'n_cor': 3}}

Decks_STO_57398459_18_2024 = {
    'Н57-750': {'h': 57, 'b': 187.5, 'b_wf': 95, 'b_tf': 44, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 0, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 0, 'h_1': 57, 'h_s1': 0, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 4},
    'Н60-845': {'h': 60, 'b': 211.25, 'b_wf': 122, 'b_tf': 50, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 0, 'b_wfs': 16, 'h_wfs': 5, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 0, 'h_1': 60, 'h_s1': 0, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 4},
    'Н75-750': {'h': 75, 'b': 187.5, 'b_wf': 92, 'b_tf': 50, 'n_wfs' : 1, 'n_tfs': 0, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 8, 'h_1': 47.5, 'h_s1': 7.5, 'h_2': 0, 'h_s2':0, 'r': 5, 'r_s': 4, 'n_cor': 4},
    'Н105-1270': {'h': 105, 'b': 423, 'b_wf': 158, 'b_tf': 52, 'n_wfs' : 2, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 29, 'h_wfs': 5, 'b_wfs_s': 61, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 5, 'h_1': 16, 'h_s1': 8, 'h_2': 57, 'h_s2':8, 'r': 5, 'r_s': 4, 'n_cor': 4},    
    'Н114-600': {'h': 114, 'b': 200.0, 'b_wf': 104, 'b_tf': 60, 'n_wfs': 1, 'n_tfs': 1, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 18, 'h_tfs': 7, 'h_ws': 8, 'h_1': 81, 'h_s1': 7, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 3},
    'Н114-750': {'h': 114, 'b': 250.0, 'b_wf': 126, 'b_tf': 80, 'n_wfs': 2, 'n_tfs': 1, 'n_ws': 1, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 42, 'b_tfs': 18, 'h_tfs': 7, 'h_ws': 8, 'h_1': 81, 'h_s1': 7, 'h_2': 0, 'h_s2': 0, 'r': 5, 'r_s': 4, 'n_cor': 3},
    'Н127-1100': {'h': 127, 'b': 366.7, 'b_wf': 160, 'b_tf': 54, 'n_wfs': 2, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 29, 'h_wfs': 5, 'b_wfs_s': 61, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 5, 'h_1': 19, 'h_s1': 11, 'h_2': 67, 'h_s2': 11, 'r': 5, 'r_s': 4, 'n_cor': 3},  
    'Н135-1000': {'h': 135, 'b': 333.3, 'b_wf': 160, 'b_tf': 54, 'n_wfs': 2, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 29, 'h_wfs': 5, 'b_wfs_s': 61, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 5, 'h_1': 19.6, 'h_s1': 12.9, 'h_2': 70, 'h_s2': 12.9, 'r': 5, 'r_s': 4, 'n_cor': 3},  
    'Н144-960': {'h': 144, 'b': 320.0, 'b_wf': 124.4, 'b_tf': 60.2, 'n_wfs': 2, 'n_tfs': 1, 'n_ws': 2, 'b_wfs': 29, 'h_wfs': 5, 'b_wfs_s': 50, 'b_tfs': 29, 'h_tfs': 5, 'h_ws': 6, 'h_1': 40, 'h_s1': 7.5, 'h_2': 49, 'h_s2': 7.5, 'r': 5, 'r_s': 4, 'n_cor': 3},
    'Н153-900': {'h': 153, 'b': 300.0, 'b_wf': 120.0, 'b_tf': 61.0, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 7, 'h_1': 40, 'h_s1': 9, 'h_2': 63, 'h_s2': 9, 'r': 5, 'r_s': 3.5, 'n_cor': 3},
    'Н157-800': {'h': 157, 'b': 266.7, 'b_wf': 121.0, 'b_tf': 62.0, 'n_wfs': 1, 'n_tfs': 0, 'n_ws': 2, 'b_wfs': 18, 'h_wfs': 7, 'b_wfs_s': 0, 'b_tfs': 0, 'h_tfs': 0, 'h_ws': 8.25, 'h_1': 43, 'h_s1': 7.5, 'h_2': 66, 'h_s2': 7.5, 'r': 5, 'r_s': 3.5, 'n_cor': 3}}

with st.sidebar:
    st.subheader('Нормы')
    code = st.selectbox('Методика расчёта', ['СП 260.1325800.2023','EN 1993-1-3:2005'], index = 0, label_visibility = 'visible', disabled = True) # Выбор норм для расчёта
    Q_en = False #st.checkbox('Несущую способность по поперечной силе определять по EN 1993-1-3', value=True, label_visibility = 'visible', disabled = False) #Выбор формулы для определения несущей способность при действии поперечной силы
    standard = st.selectbox('Стандарт на профиль',['ГОСТ 24045-2016', 'СТО 57398459-18-2024'], index = 0, label_visibility = 'visible', disabled = True) #Выбор стандарта на настил

    st.subheader('Расчетная схема') # Заголовок страницы
    if standard == 'ГОСТ 24045-2016':
        deck = st.selectbox('Настил', ['Н57-750', 'Н60-845', 'Н75-750','Н114-600', 'Н114-750', 'Н153-850'], index = 5, label_visibility = 'visible', disabled = False) #Настилы по ГОСТ 24045-2016
    elif standard == 'СТО 57398459-18-2024':
        deck = st.selectbox('Настил', ['Н57-750','Н60-845','Н75-750','Н105-1270','Н114-600','Н114-750','Н127-1100','Н135-1000','Н144-960','Н153-900','Н157-800'], index = 0, label_visibility = 'visible', disabled = False)
    grade = int(st.selectbox('Марка стали листа по ГОСТ 14918-2020', ('220', '250', '280', '320', '350', '390', '420', '450'))) # Класс прочности стали
    t_nom = float(st.slider('Номинальная толщина стенки', min_value=0.60, max_value=1.5, value=0.80, step=0.05, format='%.2f'))/1000 # Номинальная толщина стенки
    t_coat = float(st.slider('Класс покрытия', min_value=60.0, max_value=430.0, value=350.0, step=5.0, format='%f')) * (7/100) / 1000000 # Толщина защитного покрытия
    orient = st.selectbox('Сжатая полка', ('Широкая','Узкая'),) # Ориентация широких полок

    if Q_en == False:
        st.subheader('Условия опирания')
        Q_1 = st.selectbox('Конструкция опоры и полок', ['Закреплённая на опоре', 'Не закреплённая на опоре'], index = 0, label_visibility = 'visible')
        Q_2 = st.selectbox('Опорная реакция или локальная нагрузка', ['На одну полку','На две полки'], index = 0, label_visibility = 'visible')
        Q_3 = st.selectbox('Опора', ['Концевая','Промежуточная'], index=1, label_visibility='visible')
        if Q_1 == 'Закреплённая на опоре':
            if Q_2 == 'На одну полку':
                if Q_3 == 'Концевая':
                    C, C_r, C_b, C_h = 3, 0.08, 0.70, 0.055
                elif Q_3 == 'Промежуточная':
                    C, C_r, C_b, C_h = 8, 0.10, 0.17, 0.004
            elif Q_2 == 'На две полки':
                if Q_3 == 'Концевая':
                    C, C_r, C_b, C_h = 9, 0.12, 0.14, 0.040
                elif Q_3 == 'Промежуточная':
                    C, C_r, C_b, C_h = 10, 0.11, 0.21, 0.020
        elif Q_1 == 'Не закреплённая на опоре':
            if Q_2 == 'На одну полку':
                if Q_3 == 'Концевая':
                    C, C_r, C_b, C_h = 3, 0.08, 0.70, 0.055
                elif Q_3 == 'Промежуточная':
                    C, C_r, C_b, C_h = 8, 0.10, 0.17, 0.004
            elif Q_2 == 'На две полки':
                if Q_3 == 'Концевая':
                    C, C_r, C_b, C_h = 6, 0.16, 0.17, 0.050
                elif Q_3 == 'Промежуточная':
                    C, C_r, C_b, C_h = 17, 0.10, 0.10, 0.046                            
    l_a = float(st.slider('Ширина опоры', min_value=50.0, max_value=200.0, value=100.0, step=1.0, format='%f'))/1000 # Ширина опоры

    st.header('Рассчётные усилия')
    number_spans = st.slider('Количество пролётов', min_value=1, max_value=5, value=3)
    span = st.number_input('Пролёт', min_value=0.0, max_value=12.0, value=3.0, step=0.01)
    load = st.number_input('Нагрузка', min_value=0.0, max_value=10.0, value=1.0, step=0.01)

# Расчётные характеристики материалов 
ρ_s = 7850 # Плотность стали
E_s = 206000 # Модуль упругости стали
ν = 0.3 # Коэффициент поперечной деформации стали
R_y = Grades.get(grade, {}).get('R_y',0) # Расчётный предел текучести стали при растяжении, сжатии и изгибе
R_s = Grades.get(grade, {}).get('R_s',0) # Расчётный предел текучести стали на сдвиг
R_lp = Grades.get(grade, {}).get('R_lp',0) # Расчётный предел прочности стали на смятие
t = t_nom - 2 * t_coat # Расчётная толщина листа

# Выбор сортамента настилов
if standard == 'ГОСТ 24045-2016': Decks = Decks_GOST24045_2016
elif standard == 'СТО 57398459-18-2024': Decks = Decks_STO_57398459_18_2024

#Размеры
h = Decks.get(deck, {}).get('h', 0)/1000 # Высота профиля
b = Decks.get(deck, {}).get('b', 0)/1000 # Шаг гофры
b_wf = Decks.get(deck, {}).get('b_wf', 0)/1000 # Ширина широкой полки
b_tf = Decks.get(deck, {}).get('b_tf', 0)/1000 # Ширина узкой полки
r = Decks.get(deck, {}).get('r', 0)/1000 # Радиус скруглений гофр
r_s = Decks.get(deck, {}).get('r_s', 0)/1000 # Радиус скруглений ребер жесткости
    # Ребра широкой полки
n_wfs = Decks.get(deck, {}).get('n_wfs', 0) # Количество ребер широкой полки
b_wfs = Decks.get(deck, {}).get('b_wfs', 0)/1000 # Ширина ребра жесткости по широкой полке
h_wfs = Decks.get(deck, {}).get('h_wfs', 0)/1000 # Высота ребра жесктости по широкой полке
b_wfs_s = Decks.get(deck, {}).get('b_wfs_s', 0)/1000 # Шаг ребер жестокости по широкой полке
    # Ребра узкой полки
n_tfs = Decks.get(deck, {}).get('n_tfs', 0) # Количество ребер узкой полки
b_tfs = Decks.get(deck, {}).get('b_tfs', 0)/1000 # Ширина ребра жесткости по узкой полке
h_tfs = Decks.get(deck, {}).get('h_tfs', 0)/1000 # Высота ребра жесткости по узкой полке
    # Ребра стенки
n_ws = Decks.get(deck, {}).get('n_ws', 0) #Количетсво ребер стенки
h_ws = Decks.get(deck, {}).get('h_ws', 0)/1000 # Высота ребра жесткости по стенке
h_1 = Decks.get(deck, {}).get('h_1', 0)/1000 # Высота участка стенки, ближайшего к широкой полке
h_s1 = Decks.get(deck,{}).get('h_s1', 0)/1000 # Высота ребра жесткости, ближайшего к широкой полке
h_2 = Decks.get(deck, {}).get('h_2', 0)/1000 # Высота среднего участка стенки
h_s2 = Decks.get(deck, {}).get('h_s2', 0)/1000 # Высота ребра жесткости, дальнего от широкой полки
    # Дополнительные данные
n_cor = Decks.get(deck, {}).get('n_cor', 0) # Количество гофр в одном листе

# Коэффициенты для расчётов
k_σ = 4
ψ = 1

# Недостающие геометрические данные
b_w = (b - b_wf - b_tf)/2 # Горизонтальная проекция стенки
h_3 = 0 if n_ws == 0 else (h - h_1 - h_s1) if n_ws == 1 else (h - h_1 - h_s1 - h_2 - h_s2) if n_ws == 2 else None # Вертикальная проекция нижнего участка стенки
b_wf_ps = (b_wf - b_wfs_s - b_wfs) / 2 if n_wfs == 2 else (b_wf - b_wfs) / 2 # Ширина крайнего плоского участка широкой полки
b_wf_pm = 0 if (n_wfs == 0 or n_wfs == 1) else (b_wf - n_wfs * (b_wf_ps + b_wfs)) # Ширина среднего плоского участка широкой полки
b_tf_ps = (b_tf - b_tfs) / 2 if n_tfs == 1 else b_tf / 2 # Ширина крайнего плоского участка узкой полки

α = m.asin((n_ws * h_ws) / (m.sqrt(b_w**2 + h**2))) + m.atan(h / b_w) # Угол наклона стенки к горизонтали
β = 0 if n_ws == 0 else α - m.pi / 2 + m.atan((h_s1 / m.tan(α) + h_ws / m.sin(α)) / h_s1) # Угол ребер стенки
γ_wfs = m.atan(2 * h_wfs / b_wfs) # Угол ребер широкой полки
γ_tfs = 0 if n_tfs == 0 else m.atan(2 * h_tfs / b_tfs) # Угол ребер узкой полки
ω = 0 if n_ws == 0 else α - β # Угол наклона ребер стенки к горизонтали
s_1 = h_1 / m.sin(α) # Длина верхнего участка стенки
s_2 = 0 if (n_ws == 0 or n_ws == 1) else h_2 / m.sin(α) # Длина среднего участка стенки
s_3 = 0 if n_ws == 0 else h_3 / m.sin(α) # Длина нижнего участка стенки
s_s1 = 0 if n_ws == 0 else (h_s1 / m.tan(α) + h_ws / m.sin(α)) / m.cos(ω) # Длина верхнего ребра
s_s2 = 0 if (n_ws == 0 or n_ws == 1) else s_s1 # Длина нижнего ребра
s_wfs = m.sqrt((b_wfs / 2)**2 + h_wfs**2) # Длина полуребра на широкой полке
s_tfs = m.sqrt((b_tfs / 2)**2 + h_tfs**2) # Длина полуребра на узкой полке

# Проверка геометрических размеров профилиста
if (b_wf / t_nom > 300) or (b_tf / t_nom > 300):
    st.warning(' Не выполняется требование таблицы 7.1 СП 260.1325800.2023 по отношению ширины полки и толщины стенки', icon='⚠️')
elif (h / t_nom > 300) or (h / t_nom > 300 * m.sin(α)):
    st.warning(' Не выполняется требование таблицы 7.1 СП 260.1325800.2023 по соотношению высоты профиля и толщины стенки', icon='⚠️')
elif (0.25 > α / m.pi) or (α / m.pi > 0.5):
    st.warning(' Не выполняется требование таблицы 7.1 СП 260.1325800.2023 по углу наклона стенки', icon='⚠️')
elif max(r, r_s) > 0.04 * t_nom * E_s / R_y:
    st.warning(' Не выполняется требование п.7.2.8 СП 260.1325800.2023', icon='⚠️')
elif (b_wf/t_nom > 250 * h / b_wf) and (b_tf / t_nom > 250 * h / b_tf):
    st.warning(' Не выполняется требование п.7.3.1.2 СП 260.1325800.2023', icon='⚠️')
elif (h / t_nom > 220) or (min(r, r_s) / t_nom > 10):
    st.warning(' Не выполняется требование к профлию для определения несущей способность по поперечной силе', icon='⚠️')

#Геометрические характеристики полного сечения
h_ini_c = ((b_tf_ps * h + n_tfs * s_tfs * (h - h_tfs / 2) + s_3 * (h - h_3 / 2) + s_s2 * (h - h_3 - h_s2 / 2) + s_2 * (h_1 + h_s1 + h_2 / 2) + s_s1 * (h_1 + h_s1 / 2) + s_1 * (h_1 / 2) + n_wfs * s_wfs * h_wfs / 2) 
           / (b_tf_ps + n_tfs * s_tfs + s_3 + s_s2 + s_2 + s_s1 + s_1 + b_wf_ps + n_wfs * s_wfs + b_wf_pm / 2)) # Привязка центра тяжести полного сечения к широкой полке
s_ini_n = h_ini_c / m.sin(α) if (n_ws == 0 or n_ws == 1) else (h_ini_c - h_1 - h_s1)/m.sin(α) if n_ws == 2 else None # Длина сжатой зоны участка стенки
s_ini_m = s_1 - s_ini_n if (n_ws == 0 or n_ws == 1) else (s_2 - s_ini_n) if n_ws == 2 else None # Длина растянутой зоны участка стенки
L_ini = 2 * (b_tf_ps + n_tfs * s_tfs + s_3 + s_s2 + s_2 + s_s1 + s_1 + b_wf_ps + n_wfs * s_wfs + b_wf_pm / 2) # Длина полного участка
δ = 0.43 * (4 * r * α/(m.pi/2) + n_ws * 4 * r_s * β/(m.pi/2) + n_wfs * 4 * r_s * γ_wfs/(m.pi/2) + n_tfs * 4 * r_s * γ_tfs/(m.pi/2)) / L_ini # Коэффициент, учитывающий скругления профиля
A_ini = L_ini * t * (1 - δ) # Площадь полного сечения на метр
P_ini = (L_ini + (b_tf + n_tfs * (2 * s_tfs - b_tfs))/n_cor) * t_nom * ρ_s * 1 / b # Примерная масса квадратного метра профилированного настила

if n_ws == 0 or n_ws == 1:
    I_ini = (((b_wf_pm * t**3)/12 + b_wf_pm * t * (h_ini_c)**2)
             + 2 * n_wfs * ((s_wfs * t**3)/12 * m.cos(γ_wfs)**2 + (t * s_wfs**3)/12 * m.sin(γ_wfs)**2 + s_wfs * t * (h_ini_c - h_wfs / 2)**2)
             + 2 * ((b_wf_ps * t**3)/12 + b_wf_ps * t * (h_ini_c)**2)
             + 2 * ((s_ini_n * t**3)/12 * m.cos(α)**2 + (t * s_ini_n**3)/12 * m.sin(α)**2 + s_ini_n * t * (s_ini_n * m.sin(α) / 2)**2)
             + 2 * ((s_ini_m * t**3)/12 * m.cos(α)**2 + (t * s_ini_m**3)/12 * m.sin(α)**2 + s_ini_m * t * (s_ini_m * m.sin(α) / 2)**2)
             + 2 * ((s_s1 * t**3)/12 * m.cos(ω)**2 + (t * s_s1**3)/12 * m.sin(ω)**2 + s_s1 * t * (h_ini_c - h_1 - h_s1 / 2)**2)
             + 2 * ((s_3 * t**3)/12 * m.cos(α)**2 + (t * s_3**3)/12 * m.sin(α)**2 + s_3 * t * (h - h_3 / 2 - h_ini_c)**2)
             + 2 * ((b_tf_ps * t**3)/12 + b_tf_ps * t * (h - h_ini_c)**2)
             + 2 * n_tfs * ((s_tfs * t**3)/12 * m.cos(γ_tfs)**2 + (t * s_tfs**3)/12 * m.sin(γ_tfs)**2 + s_tfs * t * (h - h_ini_c - h_tfs / 2)**2)) * 1 / b * (1 - 2 * δ) # Момент инерции полного сечения без ребер стенок с учётом скруглений
elif n_ws == 2:
    I_ini = (((b_wf_pm * t**3)/12 + b_wf_pm * t * (h_ini_c)**2)
            + 2 * n_wfs * ((s_wfs * t**3)/12 * m.cos(γ_wfs)**2 + (t * s_wfs**3)/12 * m.sin(γ_wfs)**2 + s_wfs * t * (h_ini_c - h_wfs / 2)**2)
            + 2 * ((b_wf_ps * t**3)/12 + b_wf_ps * t * (h_ini_c)**2)
            + 2 * ((s_1 * t**3)/12 * m.cos(α)**2 + (t * s_1**3)/12 * m.sin(α)**2 + s_1 * t * (h_ini_c - h_1 / 2)**2)
            + 2 * ((s_s1 * t**3)/12 * m.cos(ω)**2 + (t * s_s1**3)/12 * m.sin(ω)**2 + s_s1 * t * (h_ini_c - h_1 - h_s1 / 2)**2)
            + 2 * ((s_ini_n * t**3)/12 * m.cos(α)**2 + (t * s_ini_n**3)/12 * m.sin(α)**2 + s_ini_n * t * (s_ini_n * m.sin(α) / 2)**2)
            + 2 * ((s_ini_m * t**3)/12 * m.cos(α)**2 + (t * s_ini_m**3)/12 * m.sin(α)**2 + s_ini_m * t * (s_ini_m * m.sin(α) / 2)**2)
            + 2 * ((s_s2 * t**3)/12 * m.cos(ω)**2 + (t * s_s2**3)/12 * m.sin(ω)**2 + s_s2 * t * (h_1 + h_s1 + h_2 + h_s2 / 2 - h_ini_c)**2)
            + 2 * ((s_3 * t**3)/12 * m.cos(α)**2 + (t * s_3**3)/12 * m.sin(α)**2 + s_3 * t * (h - h_3 / 2 - h_ini_c)**2)
            + 2 * ((b_tf_ps * t**3)/12 + b_tf_ps * t * (h - h_ini_c)**2)
            + 2 * n_tfs * ((s_tfs * t**3)/12 * m.cos(γ_tfs)**2 + (t * s_tfs**3)/12 * m.sin(γ_tfs)**2 + s_tfs * t * (h - h_ini_c - h_tfs / 2)**2)) * 1 / b * (1 - 2 * δ) # Момент инерции полного сечения с двумя ребрами на стенке с учётом скруглений
W_ini_wf = I_ini/h_ini_c # Момент сопротивления широких полок с учётом скруглений
W_ini_tf = I_ini/(h - h_ini_c) # Момент сопротивления узких полок с учётом скруглений

# Геометрические характеристики редуцированного сечения
z = 0
z_ini = 1

if orient == 'Широкая':
    while abs(z - z_ini) > 0.000001:
        z_ini = z
        
        # Немного геометрии для старта
        h_c = h_ini_c + z # Положение центра тяжести с учётом редукции
        s_n = h_c / m.sin(α) if (n_ws == 0 or n_ws == 1) else (h_c - h_1 - h_s1)/m.sin(α) if n_ws == 2 else None # Длина сжатой зоны среднего участка стенки с учётом редукции
        s_m = s_1 - s_n if (n_ws == 0 or n_ws == 1) else s_2 - s_n if n_ws == 2 else None # Длина растянутой зоны среднего участка стенки с учётом редукции

        # Местная устойчивость крайнего участка сжатой широкой полки
        σ_ps_cr = k_σ * (m.pi**2 * E_s * t**2)/(12 * (1 - ν**2) * b_wf_ps**2) # Критические напряжения потери устойчивости плоского участка широкой полки
        λ_ps = m.sqrt(R_y/σ_ps_cr) # Коэффициент для плоского участка широкой полки
        ρ_ps = 1.0 if λ_ps <= 0.673 else (λ_ps - 0.055 * (3 + ψ)) / (λ_ps**2) # Коэффициент редукции для плоского участка широкой полки
        b_ps_ef = ρ_ps * b_wf_ps # Эффективаня ширина плоского участка широкой полки
        b_ps_ef_e = b_ps_ef / 2 # Плоловина ширины плоского участка широкой полки

        # Местная устойчивость среднего участка сжатой широкой полки
        σ_pm_cr = k_σ * (m.pi**2 * E_s * t**2)/(12 * (1 - ν**2) * b_wf_pm**2) if n_wfs == 2 else 0 # Критические напряжения потери устойчивости плоского участка широкой полки
        λ_pm = m.sqrt(R_y/σ_pm_cr) if n_wfs == 2 else 0 # Коэффициент для плоского участка широкой полки
        ρ_pm = 1.0 if λ_pm <= 0.673 else (λ_pm - 0.055 * (3 + ψ)) / (λ_pm**2) if n_wfs == 2 else 0 # Коэффициент редукции для плоского участка широкой полки
        b_pm_ef = ρ_pm * b_wf_pm if n_wfs == 2 else 0 # Эффективная ширина плоского участка широкой полки
        b_pm_ef_e = b_pm_ef / 2 if n_wfs == 2 else 0 # Плоловина ширины плоского участка широкой полки

        # Устойчивость формы сечения сжатой широкой полки
        if n_wfs == 0:
            σ_cr_s = 0
        else:
            b_p_i = min(15 * t, b_wf_ps / 2) # Ширина свеса крайних плоских участков широкой полки для определения момента инерции
            b_pm_i = min(15 * t, b_wf_pm / 2) if n_wfs == 2 else 0 # Ширина свеса среднего плоского участка широкой полки для определения момента инерции
            A_s_i = (2 * b_p_i + 2 * b_pm_i + 2 * n_wfs * s_wfs) * t # Площадь поперечного сечения элемента жесткости сжатой широкой полки
            h_tfs_c = 2 * n_wfs * (s_wfs * h_wfs / 2) / (2 * (b_p_i + b_pm_i + n_wfs * s_wfs)) # Привязка центра тяжести элемента жесткости
            I_wfs = 2 * (((b_p_i + b_pm_i) * t**3) / 12 + ((b_p_i + b_pm_i) * t * h_tfs_c**2) + n_wfs * ((s_wfs * t**3)/12 * m.cos(γ_wfs)**2 + (t * s_wfs**3)/12 * m.sin(γ_wfs)**2 + (s_wfs * t * (h_wfs/2 - h_tfs_c)**2))) # Момент инерции элемента жесткости широкой полки
            
            # Критические напряжения потери устойчивости формы сечения полки:
            if n_wfs == 1:
                σ_cr_s = (4.2 * E_s)/A_s_i * m.sqrt((I_wfs * t**3)/(4 * b_wf_ps**2 * (2 * b_wf_ps + 3 * 2 * s_wfs)))
            elif n_wfs == 2:
                b_l = b_wf_ps + b_wfs / 2
                b_e = 2 * b_wf_ps + b_wf_pm + 4 * s_wfs
                σ_cr_s = (4.2 * E_s)/A_s_i * m.sqrt((I_wfs * t**3)/(8 * b_l**2 * (3 * b_e - 4 * b_l))) 

        # Местная устойчивость сжатого участка стенки
        s_ef_0 = 0.76 * t * m.sqrt(E_s/R_y) # Базовая эффективная ширина стенки
        if n_ws == 0:
            s_ef_1_ini = s_ef_0
            s_ef_n_ini = 1.5 * s_ef_0
            s_ef_1 = 0.4 * s_n if s_ef_1_ini + s_ef_n_ini > s_n else s_ef_1_ini
            s_ef_2 = 0
            s_ef_3 = 0
            s_ef_n = 0.6 * s_n if s_ef_1_ini + s_ef_n_ini > s_n else s_ef_n_ini
        elif n_ws == 1:
            s_ef_1_ini = s_ef_0 # Начальная ширина более сжатой зоны верхнего участка стенки
            s_ef_n_ini = 1.5 * s_ef_0 # Начальная ширина менее сжатой зоны среднего участка стенки
            s_ef_1 = s_ef_1_ini if s_ef_1_ini + s_ef_n_ini <= s_n else s_ef_1_ini / (s_ef_1_ini + s_ef_n_ini) * s_n # Ширина более сжатой зоны участка стенки
            s_ef_2 = 0
            s_ef_3 = 0
            s_ef_n = s_ef_n_ini if s_ef_1_ini + s_ef_n_ini <= s_n else s_ef_n_ini / (s_ef_1_ini + s_ef_n_ini) * s_n # Ширина менее сжатой зоны участка стенки
        elif n_ws == 2:
            s_ef_1_ini = s_ef_0 # Начальная ширина более сжатой зоны верхнего участка стенки
            s_ef_2_ini = (1 + h_1 / (2 * h_c)) * s_ef_0 # Начальная ширина менее сжатой зоны верхнего участка стенки
            s_ef_3_ini = (1 + (h_1 + h_s1) / (2 * h_c)) * s_ef_0 # Начальная ширина более сжатой зоны среднего участка стенки
            s_ef_n_ini = 1.5 * s_ef_0 # Начальная ширина менее сжатой зоны среднего участка стенки
            s_ef_1 = s_ef_1_ini if s_ef_1_ini + s_ef_2_ini <= s_1 else s_ef_1_ini / (s_ef_1_ini + s_ef_2_ini) * s_1 # Ширина более сжатой зоны верхнего участка стенки
            s_ef_2 = s_ef_2_ini if s_ef_1_ini + s_ef_2_ini <= s_1 else s_ef_2_ini / (s_ef_1_ini + s_ef_2_ini) * s_1 # Ширина менее сжатой зоны верхнего участка стенки
            s_ef_3 = s_ef_3_ini if s_ef_3_ini + s_ef_n_ini <= s_n else s_ef_3_ini / (s_ef_3_ini + s_ef_n_ini) * s_n # Ширина более сжатой зоны среднего участка стенки
            s_ef_n = s_ef_n_ini if s_ef_3_ini + s_ef_n_ini <= s_n else s_ef_n_ini / (s_ef_3_ini + s_ef_n_ini) * s_n # Ширина менее сжатой зоны среднего участка стенки

        # Устойчивость формы сечения стенки
        if n_ws == 0 or n_ws == 1:
            σ_cr_sa = 0 # Критические напряжения потери устойчивости формы сечения стенки
        else:
            if n_ws == 1:
                s_l = 0.9 * (s_1 + s_s1 + s_3) # Размер 1
            elif n_ws == 2:
                s_l = s_1 + s_s1 + s_2 + (s_s2 + s_3) / 2 # Размер 1
            s_e = s_l - s_1 - s_s1 / 2 # Размер 2
            s_i2 = min(s_ef_1, s_1/2) # Ширина свеса плоских участков ребер для определения момента инерции
            s_i3 = min(s_ef_1, s_2/2) # Ширина свеса плоских участков ребер для определения момента инерции
            A_sa_i = (s_i2 + s_s1 + s_i3) * t # Площадь поперечного сечения ребра стенки
            h_ws_c = (s_i3 * h_ws + s_s1 * h_ws/2)/(s_i2 + s_s1 + s_i3) # Положение центра тяжести ребра стенки
            I_ws = (s_i3 * t**3)/12 + (s_i3 * t * h_ws_c**2) + (s_i2 * t**3)/12 + s_i2 * t * (h_ws - h_ws_c)**2 + (s_s1 * t**3)/12 * m.cos(β)**2 + (t * s_s1**3)/12 * m.sin(β)**2 + s_s1 * t * (h_ws/2 - h_ws_c)**2 # Момент инерции ребра стенки
            σ_cr_sa = (1.05 * E_s * m.sqrt(I_ws * t**3 * s_l))/(A_sa_i * s_e * (s_l - s_e)) # Критические напряжения потери устойчивости формы сечения стенки

        # Учёт взаимного влияние ребер стенки и полки
        if n_ws == 2:
            β_s = 1 - (h_1 + h_s1/2) / h_c # Коэффициент
            σ_cr_mod = σ_cr_s / (1 + (β_s * σ_cr_s/σ_cr_sa)**4)**0.25 # Критические напряжения поетри устойчивости
        else:
            β_s = 0 # Коэффициент
            σ_cr_mod = σ_cr_s # Критические напряжения потери устойчивости

        # Редукция толщин ребер полок и стенок
        λ_d = m.sqrt(R_y/σ_cr_mod) # Коэффициент
        if λ_d <= 0.65: χ_d = 1.0
        elif 0.65 < λ_d < 1.38: χ_d = 1.47 - 0.723 * λ_d
        else: χ_d = 0.66/λ_d

        t_red_f = χ_d * t # Редуцированная толщина элемента жесткость полки
        if n_ws == 2:
            t_red_w = min(χ_d * t * m.sqrt(h_c/(h_c - h_1 - h_s1/2)), t) # Редуцированная толщина элемента жесткости стенки
        else:
            t_red_w = t

        # Геометрические характеристики сечения с учётом редукции
        h_red_c = ((n_tfs * s_tfs * t * (h - h_tfs / 2) + b_tf_ps * t * h
                    + s_3 * t * (h - h_3 / 2) + s_s1 * t_red_w * (h_1 + h_s1 / 2) + s_s2 * t * (h - h_3 - h_s2 / 2) + s_m * t * (h_c + s_m * m.sin(α) / 2) + s_ef_n * t * (h_c - s_ef_n * m.sin(α) / 2) + s_ef_3 * t_red_w * (h_1 + h_s1 + s_ef_3 * m.sin(α) / 2) + s_ef_2 * t_red_w * (h_1 - s_ef_2 * m.sin(α) / 2)
                    + s_ef_1 * t * (s_ef_1 * m.sin(α) / 2) + n_wfs * s_wfs * t_red_f * (h_wfs / 2))
                    /(n_tfs * s_tfs * t + b_tf_ps * t + s_3 * t + s_s2 * t + s_m * t + s_ef_n * t + s_ef_3 * t_red_w + s_s1 * t_red_w + s_ef_2 * t_red_w + s_ef_1 * t + b_ps_ef_e * t + b_ps_ef_e * t_red_f + n_wfs * s_wfs * t_red_f + b_pm_ef_e * t_red_f))
        z = abs(h_red_c - h_ini_c)

    I_red = (2 * n_tfs * ((s_tfs * t**3) / 12 * m.cos(γ_tfs)**2 + (t * s_tfs**3) / 12 * m.sin(γ_tfs)**2 + s_tfs * t * (h - h_red_c - h_tfs / 2)**2)
             + 2 * ((b_tf_ps * t**3) / 12 + b_tf_ps * t * (h - h_red_c)**2)
             + 2 * ((s_3 * t**3) / 12 * m.cos(α)**2 + (t * s_3**3)/ 12 * m.sin(α)**2 + s_3 * t * (h - h_red_c - h_3 / 2)**2)
             + 2 * ((s_s2 * t**3) / 12 * m.cos(ω)**2 + (t * s_s2**3) / 12 * m.sin(ω)**2 + s_s2 * t * (h - h_red_c - h_3 - h_s2 / 2)**2)
             + 2 * ((s_s1 * t_red_w**3) / 12 * m.cos(ω)**2 + (t_red_w * s_s1**3) / 12 * m.sin(ω)**2 + s_s1 * t_red_w * (h_red_c - h_1 - h_s1 / 2)**2)
             + 2 * ((s_m * t**3) / 12 * m.cos(α)**2 + (t * s_m**3) / 12 * m.sin(α)**2 + s_m * t * (s_m * m.sin(α)/2)**2)
             + 2 * ((s_ef_n * t**3) / 12 * m.cos(α)**2 + (t * s_ef_n**3) / 12 * m.sin(α)**2 + s_ef_n * t * (s_ef_n * m.sin(α)/2)**2)
             + 2 * ((s_ef_3 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_3**3) / 12 * m.sin(α)**2 + s_ef_3 * t_red_w * (h_red_c - h_1 - h_s1 - s_ef_3 * m.sin(α)/2)**2)
             + 2 * ((s_ef_2 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_2**3) / 12 * m.sin(α)**2 + s_ef_2 * t_red_w * (h_red_c - h_1 + s_ef_2 * m.sin(α)/2)**2)
             + 2 * ((s_ef_1 * t**3) / 12 * m.cos(α)**2 + (t * s_ef_1**3) / 12 * m.sin(α)**2 + s_ef_1 * t * (h_red_c - s_ef_1 * m.sin(α)/2)**2)
             + 2 * ((b_ps_ef_e * t**3) / 12 + b_ps_ef_e * t * h_red_c**2)
             + 2 * ((b_ps_ef_e * t_red_f**3) / 12 + b_ps_ef_e * t_red_f * h_red_c**2)
             + 2 * n_wfs * ((s_wfs * t_red_f**3) / 12 * m.cos(α)**2 + (t_red_f * s_wfs**3) / 12 * m.sin(α)**2 + s_wfs * t_red_f * (h_red_c - h_wfs / 2)**2)
             + 2 * ((b_pm_ef_e * t_red_f**3) / 12 + b_pm_ef_e * t_red_f * h_red_c**2))* 1/b * (1 - 2 * δ) # Момент инерции редуцированного сечения
    
    b_d = b_tf - n_tfs * b_tfs + n_tfs * 2 * s_tfs # Длина полки в зоне опирания
    if n_ws == 0:
        k_a_s = 1
    elif n_ws == 1:
        y_w = (h * s_3 * (h_s1 * m.cos(α) - s_s1 * m.sin(α) * m.cos(ω)))/(h_s1 * b_w - h * s_s1 * m.cos(ω)) # Вертикальная координата пересечения прямой с ребром стенки
        x_w = (y_w * b_w)/h # Горизонтальная координата пересечения прямой с ребром стенки
        e_min = (n_ws * h_ws * m.sqrt(x_w**2 + y_w**2))/m.sqrt(b_w**2 + h**2)
        e_max = h_ws - e_min
        k_a_s = min(1.45 - 0.05 * e_max/t, 0.95 + 35000 * t**2 * e_min/(s_3 * b_d**2)) # Коэффициент, учитывающий наличие ребер на стенки
    elif n_ws == 2:
        y_w = (h * s_3 * (h_s2 * m.cos(α) - s_s2 * m.sin(α) * m.cos(ω)))/(h_s2 * b_w - h * s_s2 * m.cos(ω)) # Вертикальная координата пересечения прямой с ребром стенки
        x_w = (y_w * b_w)/h # Горизонтальная координата пересечения прямой с ребром стенки
        e_min = (n_ws * h_ws * m.sqrt(x_w**2 + y_w**2))/m.sqrt(b_w**2 + h**2)
        e_max = h_ws - e_min
        k_a_s = min(1.45 - 0.05 * e_max/t, 0.95 + 35000 * t**2 * e_min/(s_3*b_d**2)) # Коэффициент, учитывающий наличие ребер на стенки
elif orient == 'Узкая':
    while abs(z-z_ini) > 0.000001:
        z_ini = z

        # Немного геометрии для старта
        h_c = (h - h_ini_c) + z # Положение центра тяжести с учётом редукции
        s_n = h_c / m.sin(α) if n_ws == 0 else (h_c - h_3 - h_s1) / m.sin(α) if n_ws == 1 else (h_c - h_3 - h_s2) / m.sin(α) if n_ws == 2 else None # Длина сжатой зоны среднего участка стенки с учётом редукции
        s_m = s_1 - s_n if (n_ws == 0 or n_ws == 1) else (s_2 - s_n) if n_ws == 2 else None # Длина растянутой зоны среднего участка стенки с учётом редукции

        # Местная устойчивость сжатой узкой полки
        if n_tfs == 0:
            σ_ps_cr = k_σ * (m.pi**2 * E_s * t**2)/(12 * (1 - ν**2) * (2 * b_tf_ps)**2) # Критические напряжения потери устойчивости плоского участка узкой полки
            λ_ps = m.sqrt(R_y / σ_ps_cr) # Коэффициент для плоского участка узкой полки
            ρ_ps = 1.0 if λ_ps <= 0.673 else (λ_ps - 0.055 * (3 + ψ)) / (λ_ps**2) # Коэффициент редукции для плоского участка узкой полки
            b_ps_ef = ρ_ps * (2 * b_tf_ps) # Эффективаня ширина плоского участка узкой полки
            b_ps_ef_e = b_ps_ef / 2 # Половина ширины плоского участка широкой полки
        elif n_tfs == 1:
            σ_ps_cr = k_σ * (m.pi**2 * E_s * t**2)/(12 * (1 - ν**2) * b_tf_ps**2) # Критические напряжения потери устойчивости плоского участка узкой полки
            λ_ps = m.sqrt(R_y / σ_ps_cr) # Коэффициент для плоского участка узкой полки
            ρ_ps = 1.0 if λ_ps <= 0.673 else (λ_ps - 0.055 * (3 + ψ)) / (λ_ps**2) # Коэффициент редукции для плоского участка узкой полки
            b_ps_ef = ρ_ps * b_tf_ps # Эффективаня ширина плоского участка узкой полки
            b_ps_ef_e = b_ps_ef / 2 # Половина ширины плоского участка широкой полки            

        # Устойчивость формы сечения сжатой широкой полки
        if n_tfs == 0:
            σ_cr_s = 0
        elif n_tfs == 1:
            b_p_i = min(15 * t, b_tf_ps / 2) # Ширина свеса крайних плоских участков широкой полки для определения момента инерции
            A_s_i = (2 * b_p_i + 2 * s_tfs) * t # Площадь поперечного сечения элемента жесткости сжатой широкой полки
            h_tfs_c = 2 * (s_tfs * h_tfs / 2) / (2 * (b_p_i + s_tfs)) # Привязка центра тяжести элемента жесткости
            I_tfs = 2 * ((b_p_i * t**3) / 12 + (b_p_i * t * h_tfs_c**2) + (s_tfs * t**3)/12 * m.cos(γ_tfs)**2 + (t * s_tfs**3)/12 * m.sin(γ_tfs)**2 + (s_tfs * t * (h_tfs/2 - h_tfs_c)**2)) # Момент инерции элемента жесткости широкой полки
            σ_cr_s = (4.2 * E_s)/A_s_i * m.sqrt((I_tfs * t**3) / (4 * b_tf_ps**2 * (2 * b_tf_ps + 3 * 2 * s_tfs))) # Критические напряжения потери устойчивости формы сечения полки

        # Местная устойчивость сжатого участка стенки
        s_ef_0 = 0.76 * t * m.sqrt(E_s/R_y) # Базовая эффективная ширина стенки
        if n_ws == 0:
            s_ef_1 = 0.4 * s_n
            s_ef_2 = 0
            s_ef_3 = 0
            s_ef_n = 0.6 * s_n
        elif n_ws == 1 or n_ws == 2:
            s_ef_1_ini = s_ef_0 # Начальная ширина более сжатой зоны верхнего участка стенки
            s_ef_2_ini = (1 + h_3 / (2 * h_c)) * s_ef_0 # Начальная ширина менее сжатой зоны верхнего участка стенки
            s_ef_3_ini = ((1 + (h_3 + h_s1) / (2 * h_c)) * s_ef_0) if n_ws == 1 else ((1 + (h_3 + h_s1) / (2 * h_c)) * s_ef_0) if n_ws == 2 else None # Начальная ширина более сжатой зоны среднего участка стенки
            s_ef_n_ini = 1.5 * s_ef_0 # Начальная ширина менее сжатой зоны среднего участка стенки
            s_ef_1 = s_ef_1_ini if s_ef_1_ini + s_ef_2_ini <= s_3 else s_ef_1_ini / (s_ef_1_ini + s_ef_2_ini) * s_3 # Ширина более сжатой зоны верхнего участка стенки
            s_ef_2 = s_ef_2_ini if s_ef_1_ini + s_ef_2_ini <= s_3 else s_ef_2_ini / (s_ef_1_ini + s_ef_2_ini) * s_3 # Ширина менее сжатой зоны верхнего участка стенки
            s_ef_3 = s_ef_3_ini if s_ef_3_ini + s_ef_n_ini <= s_n else s_ef_3_ini / (s_ef_3_ini + s_ef_n_ini) * s_n # Ширина более сжатой зоны среднего участка стенки
            s_ef_n = s_ef_n_ini if s_ef_3_ini + s_ef_n_ini <= s_n else s_ef_n_ini / (s_ef_3_ini + s_ef_n_ini) * s_n # Ширина менее сжатой зоны среднего участка стенки
        
        # Устойчивость формы сечения стенки
        if n_ws == 0:
            σ_cr_sa = 0 # Критические напряжения потери устойчивости формы сечения стенки
        elif n_ws == 1 or n_ws == 2:
            s_i2 = min(s_ef_1, s_3/2) # Ширина свеса плоских участков ребер для определения момента инерции
            s_i3 = min(s_ef_1, s_1/2) # Ширина свеса плоских участков ребер для определения момента инерции            
            if n_ws == 1:
                s_l = 0.9 * (s_3 + s_s1 + s_1) # Размер 1
                s_e = s_l - s_3 - s_s1 / 2 # Размер 2
                A_sa_i = (s_i2 + s_s1 + s_i3) * t # Площадь поперечного сечения ребра стенки
                h_ws_c = (s_i3 * h_ws + s_s1 * h_ws / 2)/(s_i2 + s_s1 + s_i3) # Положение центра тяжести ребра стенки
                I_ws = (s_i3 * t**3) / 12 + (s_i3 * t * h_ws_c**2) + (s_i2 * t**3) / 12 + s_i2 * t * (h_ws - h_ws_c)**2 + (s_s1 * t**3)/12 * m.cos(β)**2 + (t * s_s1**3)/12 * m.sin(β)**2 + s_s1 * t * (h_ws/2 - h_ws_c)**2 # Момент инерции ребра стенки
            elif n_ws == 2:
                s_l = s_3 + s_s2 + s_1 + (s_s1 + s_1) / 2 # Размер 1
                s_e = s_l - s_3 - s_s2 / 2 # Размер 2
                A_sa_i = (s_i2 + s_s2 + s_i3) * t # Площадь поперечного сечения ребра стенки
                h_ws_c = (s_i3 * h_ws + s_s2 * h_ws / 2)/(s_i2 + s_s2 + s_i3) # Положение центра тяжести ребра стенки
                I_ws = (s_i3 * t**3)/12 + (s_i3 * t * h_ws_c**2) + (s_i2 * t**3)/12 + s_i2 * t * (h_ws - h_ws_c)**2 + (s_s2 * t**3)/12 * m.cos(β)**2 + (t * s_s2**3)/12 * m.sin(β)**2 + s_s2 * t * (h_ws/2 - h_ws_c)**2 # Момент инерции ребра стенки
            σ_cr_sa = (1.05 * E_s * m.sqrt(I_ws * t**3 * s_l))/(A_sa_i * s_e * (s_l - s_e)) # Критические напряжения потери устойчивости формы сечения стенки
        
        # Учёт взаимного влияние ребер стенки и полки
        if n_tfs == 0:
            β_s = 0
            σ_cr_mod = σ_cr_sa
        elif n_tfs == 1:
            if n_ws == 0:
                σ_cr_mod = σ_ps_cr
            elif n_ws == 1:
                β_s = 1 - (h_3 + h_s1 / 2) / h_c # Коэффициент
                σ_cr_mod = σ_cr_s / (1 + (β_s * σ_cr_s/σ_cr_sa)**4)**0.25 # Критические напряжения поетри устойчивости
            elif n_ws == 2:
                β_s = 1 - (h_3 + h_s2 / 2) / h_c # Коэффициент
                σ_cr_mod = σ_cr_s / (1 + (β_s * σ_cr_s/σ_cr_sa)**4)**0.25 # Критические напряжения поетри устойчивости
                
        # Редукция толщин ребер полок и стенок
        if σ_cr_mod == 0:
            χ_d = 1
        else:
            λ_d = m.sqrt(R_y/σ_cr_mod) # Коэффициент
            if λ_d <= 0.65: χ_d = 1.0
            elif 0.65 < λ_d < 1.38: χ_d = 1.47 - 0.723 * λ_d
            else: χ_d = 0.66/λ_d

        if n_tfs == 0:
            t_red_f = 0
        elif n_tfs == 1:
            t_red_f = χ_d * t # Редуцированная толщина полки
        else: t_red_f = 0
        
        if n_ws == 0:
            t_red_w = 0
        elif n_ws == 1:
            t_red_w = min(χ_d * t * m.sqrt(h_c/(h_c - h_3 - h_s1/2)), t) # Редуцированная толщина элемента жесткости стенки
        elif n_ws == 2:
            t_red_w = min(χ_d * t * m.sqrt(h_c/(h_c - h_3 - h_s2/2)), t) # Редуцированная толщина элемента жесткости стенки

        # Геометрические характеристики сечения с учётом редукции
        if n_ws == 0:
            h_red_c = ((b_wf_pm / 2 * t * h + n_wfs * s_wfs * t * (h - h_wfs / 2) + b_wf_ps * t * h + s_m * t * (h_c + s_m * m.sin(α)/2) + s_ef_n * t * (h_c - s_ef_n * m.sin(α)/2) + s_ef_1 * t * (s_ef_1 * m.sin(α)/2) + n_tfs * t_red_f * (h_tfs / 2))
                    /(b_wf_pm / 2 * t + n_wfs * s_wfs * t + b_wf_ps * t + s_m * t + s_ef_n * t + s_ef_1 * t + b_ps_ef_e * t + b_ps_ef_e / 2 * t_red_f + n_tfs * s_tfs * t_red_f)) # Привязка центра тяжести редуцированного сечения            
        elif n_ws == 1:
            h_red_c = ((b_wf_pm / 2 * t * h + n_wfs * s_wfs * t * (h - h_wfs / 2) + b_wf_ps * t * h
                        + s_m * t * (h_c + s_m * m.sin(α)/2) + s_ef_n * t * (h_c - s_ef_n * m.sin(α)/2) + s_ef_3 * t_red_w * (h_3 + h_s1 + s_ef_3 * m.sin(α)/2) + s_s1 * t_red_w * (h_3 + h_s1 / 2) + s_ef_2 * t_red_w * (h_3 - s_ef_2 * m.sin(α)/2) + s_ef_1 * t * (s_ef_1 * m.sin(α)/2) + n_tfs * t_red_f * (h_tfs / 2))
                    /(b_wf_pm / 2 * t + n_wfs * s_wfs * t + b_wf_ps * t + s_m * t + s_ef_n * t + s_ef_3 * t_red_w + s_s1 * t_red_w + s_ef_2 * t_red_w + s_ef_1 * t + b_ps_ef_e * t + b_ps_ef_e / 2 * t_red_f + n_tfs * s_tfs * t_red_f)) # Привязка центра тяжести редуцированного сечения
        elif n_ws == 2:
            h_red_c = ((b_wf_pm / 2 * t * h + n_wfs * s_wfs * t * (h - h_wfs / 2) + b_wf_ps * t * h
                        + s_1 * t * (h - h_1 / 2) + s_s1 * t * (h - h_1 - h_s1 / 2) + s_m * t * (h_c + s_m * m.sin(α)/2) + s_ef_n * t * (h_c - s_ef_n * m.sin(α)/2)
                        + s_ef_3 * t_red_w * (h_3 + h_s2 + s_ef_3 * m.sin(α)/2) + s_s2 * t_red_w * (h_3 + h_s2 / 2) + s_ef_2 * t_red_w * (h_3 - s_ef_2 * m.sin(α)/2)
                        + s_ef_1 * t * (s_ef_1 * m.sin(α)/2) + n_tfs * t_red_f * (h_tfs / 2))
                    /(b_wf_pm / 2 * t + n_wfs * s_wfs * t + b_wf_ps * t + s_1 * t + s_s1 * t + s_m * t + s_ef_n * t + s_ef_3 * t_red_w + s_s2 * t_red_w + s_ef_2 * t_red_w + s_ef_1 * t + b_ps_ef_e * t + b_ps_ef_e / 2 * t_red_f + n_tfs * s_tfs * t_red_f)) # Привязка центра тяжести редуцированного сечения
        z = abs(h_red_c - (h - h_ini_c))
    if n_ws == 0:
        I_red = (((b_wf_pm / 2 * t**3) / 12 + b_wf_pm / 2 * t * (h - h_red_c)**2)
              + 2 * n_wfs * ((s_wfs * t**3) / 12 * m.cos(γ_wfs)**2 + (t * s_wfs**3) / 12 * m.sin(γ_wfs)**2 + s_wfs * t * (h - h_red_c - h_wfs / 2)**2)
              + 2 * ((b_wf_ps * t**3) / 12 + b_wf_ps * t * (h - h_red_c)**2)
              + 2 * ((s_m * t**3) / 12 * m.cos(α)**2 + (t * s_m**3) / 12 * m.sin(α)**2 + s_m * t * (s_m * m.sin(α)/2)**2)
              + 2 * ((s_ef_n * t**3) / 12 * m.cos(α)**2 + (t * s_ef_n**3) / 12 * m.sin(α)**2 + s_ef_n * t * (s_ef_n * m.sin(α)/2)**2)
              + 2 * ((s_ef_1 * t**3) / 12 * m.cos(α)**2 + (t * s_ef_1**3) / 12 * m.sin(α)**2 + s_ef_1 * t * (h_red_c - s_ef_1 * m.sin(α)/2)**2)
              + 2 * ((b_ps_ef_e * t**3) / 12 + b_ps_ef_e * t * (h_red_c)**2)
              + 2 * ((b_ps_ef_e * t_red_f**3) / 12 + b_ps_ef_e * t_red_f * (h_red_c)**2)
              + 2 * n_tfs * ((s_tfs * t_red_f**3) / 12 * m.cos(γ_tfs)**2 + (t_red_f * s_tfs**3) / 12 * m.sin(γ_tfs)**2 + s_tfs * t_red_f * (h_red_c - h_tfs / 2)**2)) * 1/b * (1 - 2 * δ) # Момент инерции редуцированного сечения
    elif n_ws == 1:
        I_red = (((b_wf_pm / 2 * t**3) / 12 + b_wf_pm / 2 * t * (h - h_red_c)**2)
              + 2 * n_wfs * ((s_wfs * t**3) / 12 * m.cos(γ_wfs)**2 + (t * s_wfs**3) / 12 * m.sin(γ_wfs)**2 + s_wfs * t * (h - h_red_c - h_wfs / 2)**2)
              + 2 * ((b_wf_ps * t**3) / 12 + b_wf_ps * t * (h - h_red_c)**2)
              + 2 * ((s_m * t**3) / 12 * m.cos(α)**2 + (t * s_m**3) / 12 * m.sin(α)**2 + s_m * t * (s_m * m.sin(α)/2)**2)
              + 2 * ((s_ef_n * t**3) / 12 * m.cos(α)**2 + (t * s_ef_n**3) / 12 * m.sin(α)**2 + s_ef_n * t * (s_ef_n * m.sin(α)/2)**2)
              + 2 * ((s_ef_3 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_3**3) / 12 * m.sin(α)**2 + s_ef_3 * t_red_w * (h_red_c - h_3 - h_s1 - s_ef_3 * m.sin(α)/2)**2)
              + 2 * ((s_s1 * t_red_w**3) / 12 * m.cos(ω)**2 + (t_red_w * s_s1**3) / 12 * m.sin(ω)**2 + s_s1 * t_red_w * (h_red_c - h_3 - h_s1 / 2)**2)
              + 2 * ((s_ef_2 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_2**3) / 12 * m.sin(α)**2 + s_ef_2 * t_red_w * (h_red_c - h_3 + s_ef_2 * m.sin(α)/2)**2)
              + 2 * ((s_ef_1 * t**3) / 12 * m.cos(α)**2 + (t * s_ef_1**3) / 12 * m.sin(α)**2 + s_ef_1 * t * (h_red_c - s_ef_1 * m.sin(α)/2)**2)
              + 2 * ((b_ps_ef_e * t**3) / 12 + b_ps_ef_e * t * (h_red_c)**2)
              + 2 * ((b_ps_ef_e * t_red_f**3) / 12 + b_ps_ef_e * t_red_f * (h_red_c)**2)
              + 2 * n_tfs * ((s_tfs * t_red_f**3) / 12 * m.cos(γ_tfs)**2 + (t_red_f * s_tfs**3) / 12 * m.sin(γ_tfs)**2 + s_tfs * t_red_f * (h_red_c - h_tfs / 2)**2)) * 1/b * (1 - 2 * δ) # Момент инерции редуцированного сечения
    elif n_ws == 2:
        I_red = (((b_wf_pm / 2 * t**3) / 12 + b_wf_pm / 2 * t * (h - h_red_c)**2)
              + 2 * n_wfs * ((s_wfs * t**3) / 12 * m.cos(γ_wfs)**2 + (t * s_wfs**3) / 12 * m.sin(γ_wfs)**2 + s_wfs * t * (h - h_red_c - h_wfs / 2)**2)
              + 2 * ((b_wf_ps * t**3) / 12 + b_wf_ps * t * (h - h_red_c)**2)
              + 2 * ((s_1 * t**3) / 12 * m.cos(α)**2 + (t * s_1**3) / 12 * m.sin(α)**2 + s_1 * t * (h - h_red_c - h_1 / 2)**2)
              + 2 * ((s_s1 * t**3) / 12 * m.cos(ω)**2 + (t * s_s1**3) / 12 * m.sin(ω)**2 + s_s1 * t * (h - h_red_c - h_1 - h_s1 / 2)**2)
              + 2 * ((s_m * t**3) / 12 * m.cos(α)**2 + (t * s_m**3) / 12 * m.sin(α)**2 + s_m * t * (s_m * m.sin(α)/2)**2)
              + 2 * ((s_ef_n * t**3) / 12 * m.cos(α)**2 + (t * s_ef_n**3) / 12 * m.sin(α)**2 + s_ef_n * t * (s_ef_n * m.sin(α)/2)**2)
              + 2 * ((s_ef_3 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_3**3) / 12 * m.sin(α)**2 + s_ef_3 * t_red_w * (h_red_c - h_3 - h_s2 - s_ef_3 * m.sin(α)/2)**2)
              + 2 * ((s_s2 * t_red_w**3) / 12 * m.cos(ω)**2 + (t_red_w * s_s2**3) / 12 * m.sin(ω)**2 + s_s2 * t_red_w * (h_red_c - h_3 - h_s2 / 2)**2)
              + 2 * ((s_ef_2 * t_red_w**3) / 12 * m.cos(α)**2 + (t_red_w * s_ef_2**3) / 12 * m.sin(α)**2 + s_ef_2 * t_red_w * (h_red_c - h_3 + s_ef_2 * m.sin(α)/2)**2)
              + 2 * ((s_ef_1 * t**3) / 12 * m.cos(α)**2 + (t * s_ef_1**3) / 12 * m.sin(α)**2 + s_ef_1 * t * (h_red_c - s_ef_1 * m.sin(α)/2)**2)
              + 2 * ((b_ps_ef_e * t**3) / 12 + b_ps_ef_e * t * (h_red_c)**2)
              + 2 * ((b_ps_ef_e * t_red_f**3) / 12 + b_ps_ef_e * t_red_f * (h_red_c)**2)
              + 2 * n_tfs * ((s_tfs * t_red_f**3) / 12 * m.cos(γ_tfs)**2 + (t_red_f * s_tfs**3) / 12 * m.sin(γ_tfs)**2 + s_tfs * t_red_f * (h_red_c - h_tfs / 2)**2)) * 1/b * (1 - 2 * δ) # Момент инерции редуцированного сечения
    
    b_d = b_wf - n_wfs * b_wfs + n_wfs * 2 * s_wfs # Длина полки в зоне опирания
    if n_ws == 0:
        k_a_s = 1
    elif n_ws == 1:
        y_w = (h * s_1 * (h_s1 * m.cos(α) - s_s1 * m.sin(α) * m.cos(ω)))/(h_s1 * b_w - h * s_s1 * m.cos(ω)) # Вертикальная координата пересечения прямой с ребром стенки
        x_w = (y_w * b_w)/h # Горизонтальная координата пересечения прямой с ребром стенки
        e_max = (n_ws * h_ws * m.sqrt(x_w**2 + y_w**2))/m.sqrt(b_w**2 + h**2)
        e_min = h_ws - e_max
        k_a_s = min(1.45 - 0.05 * e_max/t, 0.95 + 35000 * t**2 * e_min/(s_1 * b_d**2)) # Коэффициент, учитывающий наличие ребер на стенки
    elif n_ws == 2:
        y_w = (h * s_1 * (h_s1 * m.cos(α) - s_s1 * m.sin(α) * m.cos(ω)))/(h_s1 * b_w - h * s_s1 * m.cos(ω)) # Вертикальная координата пересечения прямой с ребром стенки
        x_w = (y_w * b_w)/h # Горизонтальная координата пересечения прямой с ребром стенки
        e_min = (n_ws * h_ws * m.sqrt(x_w**2 + y_w**2))/m.sqrt(b_w**2 + h**2)
        e_max = h_ws - e_min
        k_a_s = min(1.45 - 0.05 * e_max/t, 0.95 + 35000 * t**2 * e_min/(s_1*b_d**2)) # Коэффициент, учитывающий наличие ребер на стенки

# Геометрические характеристики для изгиба
W_red_wf = I_red/h_red_c # Момент сопротивления широкой полки
W_red_tf = I_red/(h - h_red_c) # Момент сопротивления узкий полки

# Несущая способность на изгиб
M_ult_wf = W_red_wf * R_y * 10**3 # Максимальный изгибающий момент для широкой полки
M_ult_tf = W_red_tf * R_y * 10**3 # Максимальные изгибающий момент для узкой полки

# Несущая способность по поперечной силе
if Q_en:
    Q_w_p = 0.15 * t**2 * m.sqrt(R_y * E_s * 10**6) * (1 - 0.1 * m.sqrt(r_s/t)) * (0.5 + m.sqrt(0.02*l_a/t)) * (2.4 + (α/(m.pi/2))**2) * k_a_s # Критическая поперечная сила потери устойчивости одной стенки гофра
else:
    if orient == 'Широкая':
        Q_w_p = C * t**2 * R_y * m.sin(α) * (1 - C_r * m.sqrt(r/t)) * (1 + C_b * m.sqrt(l_a/t)) * (1 - C_h * m.sqrt(h_3/t)) * k_a_s * 1e3
    else:
        Q_w_p = C * t**2 * R_y * m.sin(α) * (1 - C_r * m.sqrt(r/t)) * (1 + C_b * m.sqrt(l_a/t)) * (1 - C_h * m.sqrt(h_1/t)) * k_a_s * 1e3
Q_ult = 2 * Q_w_p * 1/b # Критическая сила на метр поперечного сечения настила


# Определение действующих усилий
factors = {
    1: {'k_m': 0.125, 'k_q': 0.500, 'k_f': 0.01300},
    2: {'k_m': 0.125, 'k_q': 1.250, 'k_f': 0.00520},
    3: {'k_m': 0.100, 'k_q': 1.100, 'k_f': 0.00677},
    4: {'k_m': 0.107, 'k_q': 1.143, 'k_f': 0.00630},
    5: {'k_m': 0.105, 'k_q': 1.132, 'k_f': 0.00646}
}

k_m = factors.get(number_spans, {}).get('k_m', 0)
k_q = factors.get(number_spans, {}).get('k_q', 0)
k_f = factors.get(number_spans, {}).get('k_f', 0)

M_ed = k_m * load * span**2
Q_ed = k_q * load * span
F_ed = k_f * load * span**4 / (E_s * I_red)

# Сечение настила с учётом редукции
def draw_section():
    fig = go.Figure()

    if orient == 'Широкая':
        if n_wfs == 1 and n_ws == 0 and n_tfs == 0:
            main_points = [
                [(-b / 2 , 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + (s_m + s_ef_n) * m.cos(α),(s_m + s_ef_n) * m.sin(α))],
                 [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_wf / 2, h),
                  (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_ps_ef_e - b_wfs / 2, h),
                 (-b_wfs / 2, h),
                 (0, h - h_wfs)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_m + s_ef_n) * m.cos(α),(s_m + s_ef_n) * m.sin(α)),
                 (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_ps_ef_e - b_wfs / 2, h)]]
        elif n_wfs == 1 and n_ws == 1 and n_tfs == 0:
            main_points = [
                [(-b / 2 , 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α), s_3 * m.sin(α)),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α) + s_s1 * m.cos(ω), s_3 * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω))],
                [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wf / 2, h),
                 (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wfs / 2 - b_ps_ef_e, h),
                 (-b_wfs / 2, h),
                 (0, h - h_wfs)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_ps_ef_e - b_wfs / 2, h)]]
        elif n_wfs == 1 and n_ws == 1 and n_tfs == 1:
            main_points = [
                [(-b / 2 , h_tfs),
                 (-b / 2 + b_tfs / 2, 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α), s_3 * m.sin(α)),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α) + s_s1 * m.cos(ω), s_3 * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω))],
                [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wf / 2, h),
                 (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wfs / 2 - b_ps_ef_e, h),
                 (-b_wfs / 2, h),
                 (0, h - h_wfs)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_ps_ef_e - b_wfs / 2, h)]]
        elif n_wfs == 2 and n_ws == 1 and n_tfs == 1:
            main_points = [
                [(-b / 2 , h_tfs),
                 (-b / 2 + b_tfs / 2, 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α), s_3 * m.sin(α)),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α) + s_s1 * m.cos(ω), s_3 * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω))],
                [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wf / 2, h),
                 (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2, h),
                 (-b_wfs_s / 2, h - h_wfs),
                 (-b_wfs_s / 2 + b_wfs / 2 , h),
                 (-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h)],
                 [(-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h),
                  (0,h)]]
        elif n_wfs == 2 and n_ws == 2 and n_tfs == 1:
            main_points = [
                [(-b / 2, h_tfs),
                 (-b / 2 + b_tfs / 2, 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α), h_3),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2),
                 (-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2 + (s_m + s_ef_n) * m.sin(α))],
                [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wf / 2, h),
                 (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wf / 2 - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_wf / 2 - s_1 * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1),
                 (-b_wf / 2 - s_1 * m.cos(α), h - h_1),
                 (-b_wf / 2 - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α))],
                [(-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2, h),
                 (-b_wfs_s / 2, h - h_wfs),
                 (-b_wfs_s / 2 + b_wfs / 2, h),
                 (-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_wf / 2 - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α)),
                  (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h)],
                [(-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h),
                  (0,h)]]                 
        elif n_wfs == 1 and n_ws == 2 and n_tfs == 0:
            main_points = [
                [(-b/2, 0),
                 (-b/2 + b_tf/2, 0),
                 (-b/2 + b_tf/2 + s_3 * m.cos(α), h_3),
                 (-b/2 + b_tf/2 + s_3 * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2),
                 (-b/2 + b_tf/2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2 + (s_m + s_ef_n) * m.sin(α))],
                [(-b_wfs/2 - b_wf_ps - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wfs/2 - b_wf_ps, h), 
                 (-b_wfs/2 - b_wf_ps + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wfs/2 - b_wf_ps - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α)),
                (-b_wfs/2 - b_wf_ps - s_1 * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1),
                (-b_wfs/2 - b_wf_ps - s_1 * m.cos(α), h - h_1),
                (-b_wfs/2 - b_wf_ps - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α))],
                [(-b_wfs/2 - b_ps_ef_e, h),
                (-b_wfs/2, h),
                (0, h - h_wfs)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_wf / 2 - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α)),
                  (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h)]]
        elif n_wfs == 2 and n_ws == 2 and n_tfs == 0:
            main_points = [
                [(-b / 2, 0),
                 (-b / 2 + b_tf / 2, 0),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α), h_3),
                 (-b / 2 + b_tf / 2 + s_3 * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2),
                 (-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), h_3 + h_s2 + (s_m + s_ef_n) * m.sin(α))],
                [(-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_wf / 2, h),
                 (-b_wf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_wf / 2 - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_wf / 2 - s_1 * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1),
                 (-b_wf / 2 - s_1 * m.cos(α), h - h_1),
                 (-b_wf / 2 - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α))],
                [(-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2, h),
                 (-b_wfs_s / 2, h - h_wfs),
                 (-b_wfs_s / 2 + b_wfs / 2, h),
                 (-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h)]]
            inactive_segments = [
                [(-b / 2 + b_tf / 2 + (s_3 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), (s_3 + s_m + s_ef_n) * m.sin(α) + s_s1 * m.sin(ω)),
                 (-b_wf / 2 - (s_1 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_1 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_wf / 2 - s_1 * m.cos(α) + s_ef_2 * m.cos(α), h - h_1 + s_ef_2 * m.sin(α)),
                  (-b_wf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_wf / 2 + b_ps_ef_e, h),
                 (-b_wfs_s / 2 - b_wfs / 2 - b_ps_ef_e, h)],
                [(-b_wfs_s / 2 + b_wfs / 2 + b_pm_ef_e, h),
                  (0,h)]]    
        
    elif orient == 'Узкая':
        if n_wfs == 1 and n_ws == 0 and n_tfs == 0:
            main_points = [
                [(-b / 2, h_wfs),
                 (-b / 2 + b_wfs / 2, 0),
                 (-b / 2 + b_wf / 2, 0),
                 (-b / 2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α)),
                 (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                 (-b_tf / 2, h),
                 (-b_tf / 2 + b_ps_ef_e,h)]]
            reduced_segments = []
            inactive_segments = [[(-b_tf / 2 + b_ps_ef_e,h),
                                  (0, h)]]
        elif n_wfs == 1 and n_ws == 1 and n_tfs == 0:
            main_points = [
                [(-b/2, h_wfs),
                 (-b/2 + b_wfs / 2, 0),
                 (-b/2 + b_wf / 2, 0),
                 (-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α))],
                 [(-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_tf / 2, h),
                  (-b_tf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_tf / 2 - s_3 * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1),
                 (-b_tf / 2 - s_3 * m.cos(α), h - h_3),
                 (-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))]]
            inactive_segments = [
                [(-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α)),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e,h),
                 (0, h)]]
        elif n_wfs == 1 and n_ws == 1 and n_tfs == 1:
            main_points = [
                [(-b/2, h_wfs),
                 (-b/2 + b_wfs / 2, 0),
                 (-b/2 + b_wf / 2, 0),
                 (-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α))],
                 [(-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_tf / 2, h),
                  (-b_tf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_tf / 2 - s_3 * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1),
                 (-b_tf / 2 - s_3 * m.cos(α), h - h_3),
                 (-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))],
                 [(-b_tfs / 2 - b_ps_ef_e, h),
                  (-b_tfs / 2, h),
                  (0, h - h_tfs)]]
            inactive_segments = [
                [(-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α)),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e,h),
                 (-b_tfs / 2 - b_ps_ef_e, h)]]
        elif n_wfs == 2 and n_ws == 1 and n_tfs == 1:
            main_points = [
                [(-b / 2, 0),
                 (-b / 2 + b_wf_pm /2, 0),
                 (-b / 2 + b_wf_pm / 2 + b_wfs / 2, h_wfs),
                 (-b / 2 + b_wf_pm / 2 + b_wfs, 0),
                 (-b/2 + b_wf / 2, 0),
                 (-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α))],
                 [(-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_tf / 2, h),
                  (-b_tf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_tf / 2 - s_3 * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1),
                 (-b_tf / 2 - s_3 * m.cos(α), h - h_3),
                 (-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))],
                 [(-b_tfs / 2 - b_ps_ef_e, h),
                  (-b_tfs / 2, h),
                  (0, h - h_tfs)]]
            inactive_segments = [
                [(-b/2 + b_wf / 2 + (s_m + s_ef_n) * m.cos(α), (s_m + s_ef_n) * m.sin(α)),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e,h),
                 (-b_tfs / 2 - b_ps_ef_e, h)]]
        elif n_wfs == 2 and n_ws == 2 and n_tfs == 1:
            main_points = [
                [(-b / 2, 0),
                 (-b / 2 + b_wf_pm /2, 0),
                 (-b / 2 + b_wf_pm / 2 + b_wfs / 2, h_wfs),
                 (-b / 2 + b_wf_pm / 2 + b_wfs, 0),
                 (-b / 2 + b_wf / 2, 0),
                 (-b / 2 + b_wf / 2 + s_1 * m.cos(α), s_1 * m.sin(α)),
                 (-b / 2 + b_wf / 2 + s_1 * m.cos(α) + s_s2 * m.cos(ω), s_1 * m.sin(α) + h_s2),
                 (-b / 2 + b_wf / 2 + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), (s_1 + s_m + s_ef_n) * m.sin(α) + h_s2)],
                 [(-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_tf / 2, h),
                  (-b_tf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_tf / 2 - s_3 * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1),
                 (-b_tf / 2 - s_3 * m.cos(α), h - h_3),
                 (-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))],
                 [(-b_tfs / 2 - b_ps_ef_e, h),
                  (-b_tfs / 2, h),
                  (0, h - h_tfs)]]
            inactive_segments = [
                [(-b / 2 + b_wf / 2 + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), (s_1 + s_m + s_ef_n) * m.sin(α) + h_s2),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e,h),
                 (-b_tfs / 2 - b_ps_ef_e, h)]]          
        elif n_wfs == 1 and n_ws == 2 and n_tfs == 0:
            main_points = [
                [(-b/2, h_wfs),
                (-b/2 + b_wfs/2, 0),
                (-b/2 + b_wfs/2 + b_wf_ps, 0),
                (-b/2 + b_wfs/2 + b_wf_ps + s_1 * m.cos(α), h_1),
                (-b/2 + b_wfs/2 + b_wf_ps + s_1 * m.cos(α) + s_s1 * m.cos(ω), h_1 + h_s1),
                (-b/2 + b_wfs/2 + b_wf_ps + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s1 * m.cos(ω), h_1 + h_s1 + (s_m + s_ef_n) * m.sin(α))],
                [(-b_tf/2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                (-b_tf/2, h),
                (-b_tf/2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf/2 - (s_3 + s_ef_3) * m.cos(α) - s_s2 * m.cos(ω), h - h_3 - h_s2 - s_ef_3 * m.sin(α)),
                (-b_tf/2 - s_3 * m.cos(α) - s_s2 * m.cos(ω), h - h_3 - h_s2),
                (-b_tf/2 - s_3 * m.cos(α), h - h_3),
                (-b_tf/2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))]]
            inactive_segments = [
                [(-b / 2 + b_wf / 2 + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), (s_1 + s_m + s_ef_n) * m.sin(α) + h_s2),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e, h),
                 (0, h)]]
        elif n_wfs == 2 and n_ws == 2 and n_tfs == 0:
            main_points = [
                [(-b / 2, 0),
                 (-b / 2 + b_wf_pm /2, 0),
                 (-b / 2 + b_wf_pm / 2 + b_wfs / 2, h_wfs),
                 (-b / 2 + b_wf_pm / 2 + b_wfs, 0),
                 (-b / 2 + b_wf / 2, 0),
                 (-b / 2 + b_wf / 2 + s_1 * m.cos(α), s_1 * m.sin(α)),
                 (-b / 2 + b_wf / 2 + s_1 * m.cos(α) + s_s2 * m.cos(ω), s_1 * m.sin(α) + h_s2),
                 (-b / 2 + b_wf / 2 + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), (s_1 + s_m + s_ef_n) * m.sin(α) + h_s2)],
                 [(-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α)),
                  (-b_tf / 2, h),
                  (-b_tf / 2 + b_ps_ef_e, h)]]
            reduced_segments = [
                [(-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α)),
                 (-b_tf / 2 - s_3 * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1),
                 (-b_tf / 2 - s_3 * m.cos(α), h - h_3),
                 (-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α))],]
            inactive_segments = [
                [(-b / 2 + b_wf / 2 + (s_1 + s_m + s_ef_n) * m.cos(α) + s_s2 * m.cos(ω), (s_1 + s_m + s_ef_n) * m.sin(α) + h_s2),
                 (-b_tf / 2 - (s_3 + s_ef_3) * m.cos(α) - s_s1 * m.cos(ω), h - h_3 - h_s1 - s_ef_3 * m.sin(α))],
                [(-b_tf / 2 - s_3 * m.cos(α) + s_ef_2 * m.cos(α), h - h_3 + s_ef_2 * m.sin(α)),
                  (-b_tf / 2 - s_ef_1 * m.cos(α), h - s_ef_1 * m.sin(α))],
                [(-b_tf / 2 + b_ps_ef_e,h),
                 (0, h)]]       
    
    # Рисуем основные участки синим
    for segment in main_points:
        x = [p[0] * 1000 for p in segment]
        y = [p[1] * 1000 for p in segment]
        
        # Основной сегмент
        fig.add_trace(go.Scatter(x=x, y=y,
            mode='lines', line=dict(color='blue', width=4),
            showlegend=False, name = 'ini'))
        
        # Зеркальное отражение
        x_mirror = [-p[0]*1000 for p in segment]
        fig.add_trace(go.Scatter(x=x_mirror, y=y,
            mode='lines', line=dict(color='blue', width=4),
            showlegend=False, name = 'ini'))

    # Рисуем редуцированные участки оранжевым
    reduced_color = 'rgb(' + str(int(255 * (1 - χ_d))) + ',' + str(int(0)) + ',' + str(int(255 * χ_d)) + ')'
    for segment in reduced_segments:
        x = [p[0]*1000 for p in segment]
        y = [p[1]*1000 for p in segment]
        
        fig.add_trace(go.Scatter(x=x, y=y,
            mode='lines', line=dict(color=reduced_color, width=4*χ_d),
            showlegend=False, name = 'red'))
        
        # Зеркальное отражение
        x_mirror = [-p[0]*1000 for p in segment]
        fig.add_trace(go.Scatter(x=x_mirror, y=y,
            mode='lines', line=dict(color=reduced_color, width=4*χ_d),
            showlegend=False, name = 'red'))
        
    # Рисуем выключенные участки серым
    for segment in inactive_segments:
        x = [p[0]*1000 for p in segment]
        y = [p[1]*1000 for p in segment]
        
        fig.add_trace(go.Scatter(x=x, y=y,
            mode='lines', line=dict(color='gray', width=2, dash='dash'),
            showlegend=False, name = 'red'))
        
        # Зеркальное отражение
        x_mirror = [-p[0]*1000 for p in segment]
        fig.add_trace(go.Scatter(x=x_mirror, y=y,
            mode='lines', line=dict(color='gray', width=2, dash='dash'),
            showlegend=False, name = 'red'))
    
    # Главные оси инерции
    if orient == 'Широкая':    
        #fig.add_trace(go.Scatter(x=[-b/ 2, b / 2], y=[h - h_ini_c,h - h_ini_c],
            #mode='lines', line=dict(color='blue', width=1, dash='dashdot'), name='ini'))
        fig.add_trace(go.Scatter(x=[-b * 1000 / 2, b*1000 / 2], y=[(h - h_red_c)*1000,(h - h_red_c)*1000],
            mode='lines', line=dict(color=reduced_color, width=1, dash='dashdot'), name='red'))
    elif orient == 'Узкая':
        #fig.add_trace(go.Scatter(x=[-b/ 2, b / 2], y=[h_ini_c,h_ini_c],
            #mode='lines', line=dict(color='blue', width=1, dash='dashdot'), name='ini'))
        fig.add_trace(go.Scatter(x=[-b*1000 / 2, b*1000 / 2], y=[(h - h_red_c)*1000,(h - h_red_c)*1000],
            mode='lines', line=dict(color=reduced_color, width=1, dash='dashdot'), name='red'))        
    
    # Центр тяжести
    if orient == 'Широкая':
        #fig.add_trace(go.Scatter(x=[0], y=[h - h_ini_c],
            #mode='markers', marker=dict(color='blue', size=7.5),
            #showlegend=False, name='ini'))
        fig.add_trace(go.Scatter(x=[0], y=[(h - h_red_c)*1000],
            mode='markers', marker=dict(color=reduced_color, size=7.5),
            showlegend=False, name='red'))   
    elif orient == 'Узкая':
        #fig.add_trace(go.Scatter(x=[0], y=[h_ini_c],
            #mode='markers', marker=dict(color='blue', size=7.5),
            #showlegend=False, name='ini'))
        fig.add_trace(go.Scatter(x=[0], y=[(h - h_red_c)*1000],
            mode='markers', marker=dict(color=reduced_color, size=7.5),
            showlegend=False, name='red'))
    
    # Настройки графика
    fig.update_layout(
        xaxis=dict(showgrid=True, zeroline=True, mirror=True, ticks='outside', range=[-b * 1000/2, b*1000/2], side='bottom'),
        yaxis=dict(scaleanchor="x", scaleratio=1, range=[0, h*1000], zeroline=True, mirror=True, ticks='outside', side='left'),
        xaxis2=dict(overlaying='x', side='top', ticks='outside', mirror=True),
        yaxis2=dict(overlaying='y', side='right', ticks='outside', mirror=True),
        showlegend=False, template='plotly_dark')

    return fig

def draw_capasity_contour():
    M_ult = min(M_ult_wf, M_ult_tf) # Предельный изгибающий момент

    fig = go.Figure()

    q, m = [], []
    for i in np.linspace(0, Q_ult, 100):
        q.append(i)
        m.append(min((1.25 - i / Q_ult) * M_ult, M_ult))
    q.append(Q_ult)
    m.append(0.0)

    fig.add_trace(go.Scatter(x=q, y=m,
        mode='lines', line=dict(color = 'deepskyblue', width=2),
        fill='tozerox', fillcolor='rgba(0,191,255,0.2)', name='Capacity Line'))
        
    color_i = 'lime' if (M_ed/M_ult + Q_ed/Q_ult <= 1.25) and (M_ed/M_ult <= 1) and (Q_ed/Q_ult <= 1) else 'red'
    fig.add_trace(go.Scatter(x=[Q_ed], y=[M_ed],
        mode='markers', marker=dict(color=color_i, size=7.5),
        showlegend=False, name = 'def='+f'{F_ed:.2f} мм')) 

    fig.update_layout(
        xaxis=dict(title='Момент x-x', showgrid=True, range=[0, 1.05 * Q_ult]),
        yaxis=dict(title='Поперечная сила',showgrid=True, range=[0, 1.05 * M_ult]),
        showlegend=False, height = 1000, template='plotly_dark')

    return fig

#Результаты:
col_l, col_r = st.columns([1, 3])
with col_l:
    st.header('Сечение гофры настила', divider = 'gray') # Заголовок страницы
    st.plotly_chart(draw_section())

    st.subheader('Геометрические характеристики полного сечения', divider = 'gray')
    st.latex('t_{cor}='+f'{t*1e3:.4f}' +'\; mm ' + '\;\;\;\;'+'I_{x.ini}='+f'{I_ini*1e8:.2f}' +'\; cm^4 ')
    st.latex('W_{x.ini.wf}='+f'{W_ini_wf*1e6:.2f}' +'\; cm^3 ' + '\;\;\;\;' + 'W_{x.ini.tf}='+f'{W_ini_tf*1e6:.2f}' +'\; cm^3 ')
    
    st.subheader('Геометрические характеристики редуцированного сечения', divider = 'gray')       
    st.latex('t_{red.f}='+f'{t_red_f*1e3:.4f}' +'\; mm ' + '\;\;\;\;' + 't_{red.w}='+f'{t_red_w*1e3:.4f}' +'\; mm ' + '\;\;\;\;' + 'I_{x.red}='+f'{I_red*1e8:.2f}' +'\; cm^4 ')
    st.latex('W_{x.red.wf}='+f'{W_red_wf*1e6:.2f}' +'\; cm^3 ' + '\;\;\;\;' + 'W_{x.red.wf}='+f'{W_red_tf*1e6:.2f}' +'\; cm^3 ')
    st.latex('M_{ult}='+f'{min(M_ult_wf, M_ult_tf):.2f}' + '\; kNm' + '\;\;\;\;' + 'Q_{ult}='+f'{Q_ult:.2f}' + '\; kN')

with col_r:
    st.header('Область прочности', divider = 'gray')
    st.plotly_chart(draw_capasity_contour(), use_container_width=False, wight = 1000)
